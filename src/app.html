<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<link rel="manifest" href="%sveltekit.assets%/manifest.json" />
		<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Bitter:wght@400;500;600;700;800;900&family=Inter:wght@400;500;600;700;800;900&display=swap"
			rel="stylesheet"
		/>
		<style>
			/* Prevent flash by hiding body until theme is applied */
			body {
				visibility: hidden;
			}
			body.theme-loaded {
				visibility: visible;
			}
		</style>
		<script>
			// Blocking script to prevent theme flash - runs before page renders
			(function () {
				const STORAGE_KEY_CURRENT = 'current-theme';
				const DEFAULT_THEME = {
					primary: 'CE1126',
					secondary: '14213D',
					neutral: 'EEDBCE',
					accent: '04669A'
				};
				const ZINC_PALETTE = {
					25: 'FDFDFD',
					50: 'FAFAFA',
					100: 'F4F4F5',
					200: 'E4E4E7',
					300: 'D4D4D8',
					400: 'A1A1AA',
					500: '71717A',
					600: '52525B',
					700: '3F3F46',
					800: '27272A',
					900: '18181B',
					950: '09090B'
				};

				// Load theme from localStorage
				let theme = DEFAULT_THEME;
				try {
					const stored = localStorage.getItem(STORAGE_KEY_CURRENT);
					if (stored) {
						const parsed = JSON.parse(stored);
						if (
							parsed &&
							typeof parsed === 'object' &&
							'primary' in parsed &&
							'secondary' in parsed &&
							'accent' in parsed
						) {
							// Migrate old themes
							if ('tertiary' in parsed && !('neutral' in parsed)) {
								parsed.neutral = '';
							}
							if (!('neutral' in parsed)) {
								parsed.neutral = '';
							}
							theme = parsed;
						}
					}
				} catch (e) {
					// Use defaults on error
				}

				// Generate palette function (inline version)
				function generatePalette(baseHex) {
					const hexToRgb = (hex) => {
						const cleanHex = hex.replace('#', '');
						return {
							r: parseInt(cleanHex.substring(0, 2), 16),
							g: parseInt(cleanHex.substring(2, 4), 16),
							b: parseInt(cleanHex.substring(4, 6), 16)
						};
					};
					const rgbToHex = (r, g, b) => {
						const toHex = (c) => {
							const hex = Math.round(c).toString(16);
							return hex.length === 1 ? '0' + hex : hex;
						};
						return (toHex(r) + toHex(g) + toHex(b)).toUpperCase();
					};
					const mix = (color, mixColor, weight) => ({
						r: color.r + (mixColor.r - color.r) * weight,
						g: color.g + (mixColor.g - color.g) * weight,
						b: color.b + (mixColor.b - color.b) * weight
					});

					const base = hexToRgb(baseHex);
					const white = { r: 255, g: 255, b: 255 };
					const black = { r: 0, g: 0, b: 0 };
					const cleanBaseHex = baseHex.replace('#', '').toUpperCase();

					return {
						25: rgbToHex(
							mix(base, white, 0.975).r,
							mix(base, white, 0.975).g,
							mix(base, white, 0.975).b
						),
						50: rgbToHex(
							mix(base, white, 0.75).r,
							mix(base, white, 0.75).g,
							mix(base, white, 0.75).b
						),
						100: rgbToHex(
							mix(base, white, 0.6).r,
							mix(base, white, 0.6).g,
							mix(base, white, 0.6).b
						),
						200: rgbToHex(
							mix(base, white, 0.4).r,
							mix(base, white, 0.4).g,
							mix(base, white, 0.4).b
						),
						300: rgbToHex(
							mix(base, white, 0.25).r,
							mix(base, white, 0.25).g,
							mix(base, white, 0.25).b
						),
						400: rgbToHex(
							mix(base, white, 0.1).r,
							mix(base, white, 0.1).g,
							mix(base, white, 0.1).b
						),
						500: cleanBaseHex,
						600: rgbToHex(
							mix(base, black, 0.1).r,
							mix(base, black, 0.1).g,
							mix(base, black, 0.1).b
						),
						700: rgbToHex(
							mix(base, black, 0.2625).r,
							mix(base, black, 0.2625).g,
							mix(base, black, 0.2625).b
						),
						800: rgbToHex(
							mix(base, black, 0.425).r,
							mix(base, black, 0.425).g,
							mix(base, black, 0.425).b
						),
						900: rgbToHex(
							mix(base, black, 0.5875).r,
							mix(base, black, 0.5875).g,
							mix(base, black, 0.5875).b
						),
						950: rgbToHex(
							mix(base, black, 0.75).r,
							mix(base, black, 0.75).g,
							mix(base, black, 0.75).b
						)
					};
				}

				// Apply theme to document root immediately
				const root = document.documentElement;
				const colorNames = ['primary', 'secondary', 'accent'];

				// Apply primary, secondary, and accent palettes
				for (const colorName of colorNames) {
					const baseHex = theme[colorName];
					const palette = generatePalette(baseHex);
					for (const [shade, hexValue] of Object.entries(palette)) {
						const hexWithHash = hexValue.startsWith('#') ? hexValue : '#' + hexValue;
						root.style.setProperty('--color-' + colorName + '-' + shade, hexWithHash);
					}
				}

				// Apply neutral palette (use zinc if empty)
				if (theme.neutral && theme.neutral.trim() !== '') {
					const neutralPalette = generatePalette(theme.neutral);
					for (const [shade, hexValue] of Object.entries(neutralPalette)) {
						const hexWithHash = hexValue.startsWith('#') ? hexValue : '#' + hexValue;
						root.style.setProperty('--color-neutral-' + shade, hexWithHash);
					}
				} else {
					// Use zinc default palette
					for (const [shade, hexValue] of Object.entries(ZINC_PALETTE)) {
						root.style.setProperty('--color-neutral-' + shade, '#' + hexValue);
					}
				}

				// Show body after theme is applied
				if (document.body) {
					document.body.classList.add('theme-loaded');
				} else {
					// Fallback: show body when DOM is ready
					document.addEventListener('DOMContentLoaded', function () {
						document.body.classList.add('theme-loaded');
					});
				}
			})();

			// Fallback: ensure body is visible even if script fails
			setTimeout(function () {
				if (document.body && !document.body.classList.contains('theme-loaded')) {
					document.body.classList.add('theme-loaded');
				}
			}, 100);
		</script>
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>
